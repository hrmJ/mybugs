model{

       # LIKELIHOOD
       #==================================================================

        for (lang.idx in 1:nLang){ for (pos.idx in 1:nPos) { for (morph.idx in 1:nMorph) { for (funct.idx in 1:nFunct) { for(clausestatus.idx in 1:nClausestatus) { 
            observations[lang.idx,pos.idx,morph.idx,funct.idx,clausestatus.idx,1:Nlocations] ~ dmulti( probs[lang.idx,pos.idx,morph.idx,funct.idx,clausestatus.idx,1:Nlocations] , totals[lang.idx,pos.idx,morph.idx, funct.idx, clausestatus.idx]  )
            for (loc.idx in 1:Nlocations) {                                         
                probs[lang.idx,pos.idx,morph.idx,funct.idx,clausestatus.idx,loc.idx]  <- phi[lang.idx,pos.idx,morph.idx,funct.idx,clausestatus.idx, loc.idx] / sum(phi[lang.idx,pos.idx,morph.idx,funct.idx,clausestatus.idx,1:Nlocations])
                log(phi[lang.idx,pos.idx,morph.idx,funct.idx,clausestatus.idx,loc.idx]) <- location[loc.idx] + lang[lang.idx,loc.idx]  +  pos[pos.idx,loc.idx]  + lang.pos[lang.idx,pos.idx,loc.idx] + b.morph[morph.idx,loc.idx] + b.lang.morph[lang.idx, morph.idx, loc.idx] +  b.funct[funct.idx,loc.idx] + b.lang.funct[lang.idx, funct.idx, loc.idx] + b.funct[funct.idx,loc.idx] + b.lang.clausestatus[lang.idx, clausestatus.idx, loc.idx] 
            }}
         }}}}


       # PRIORIT + interaktiot
       #==================================================================

           for(k in 1:Nlocations){
               alpha[k] <- 1
           }

           location[1:Nlocations] ~ ddirich(alpha[])

           #------------------------------------------------------------

           sigma.lang ~ dt(0,1,1) T(0,) #puoli-cauchy |-----------
           tau.lang  <- pow(sigma.lang,-2)

           for(k in 1:Nlocations){
                   lang.raw[k] ~ dnorm(0, tau.lang)
                   lang[1, k] <- lang.raw[k] - mean(lang.raw[])
                   lang[2, k] <- -lang[1,k]
           }

           #------------------------------------------------------------

           for(morph.idx in 1:nMorph){
               morph[morph.idx, 1:Nlocations] ~ ddirich(alpha[])
               for(lang.idx in 1:nLang){
                   lang.morph[lang.idx, morph.idx, 1:Nlocations] ~ ddirich(alpha[])
               }
           }


           for(funct.idx in 1:nFunct){
               funct[funct.idx, 1:Nlocations] ~ ddirich(alpha[])
               for(lang.idx in 1:nLang){
                   lang.funct[lang.idx, funct.idx, 1:Nlocations] ~ ddirich(alpha[])
               }
           }

           for(clausestatus.idx in 1:nClausestatus){
               clausestatus[clausestatus.idx, 1:Nlocations] ~ ddirich(alpha[])
               for(lang.idx in 1:nLang){
                   lang.clausestatus[lang.idx, clausestatus.idx, 1:Nlocations] ~ ddirich(alpha[])
               }
           }

       # BINÄÄRISET
       #------------------------------------------------------------------

           sigma.pos ~ dt(0,1,1) T(0,) #puoli-cauchy |-----------
           tau.pos  <- pow(sigma.pos,-2)
           sigma.lang.pos ~ dt(0,1,1) T(0,) #puoli-cauchy |-----------
           tau.lang.pos  <- pow(sigma.lang.pos,-2)

           for(k in 1:Nlocations){
                   pos.raw[k] ~ dnorm(0, tau.pos)
                   pos[1,k] <- pos.raw[k] - mean(pos.raw[])
                   pos[2,k] <- -pos[1,k]

                   #interaktio
                   lang.pos.raw[k] ~  dnorm(0, tau.lang.pos)
                   lang.pos[1,1,k] <- lang.pos.raw[k] - mean(lang.pos.raw[])
                   lang.pos[1,2,k] <- -lang.pos[1,1,k]
                   lang.pos[2,1,k] <- -lang.pos[1,1,k]
                   lang.pos[2,2,k] <- lang.pos[1,1,k]
           }



    # SD --------------------------------------------------------------------------------
           std.lang <- sd(lang[,])
           std.pos <- sd(pos[,])
           std.funct <- sd(b.funct[,])
           std.morph <- sd(b.morph[,])
           std.clausestatus <- sd(b.clausestatus[,])

           std.lang.pos <- sd(lang.pos[,,])
           std.lang.morph <- sd(b.lang.morph[,,])
           std.lang.funct <- sd(b.lang.funct[,,])
           std.lang.clausestatus <- sd(b.lang.clausestatus[,,])

           
#           for (k in 1:Nlocations) {                                         #y. LOCATIONS
#              gt0[k] <- step(lang.pos[1,1,k])
#           }



#SUM-TO-ZERO ------------------------------------------------------------

       for(loc.idx in 1:Nlocations){
           #Voiko näin tehdä?? >>
           for (lang.idx in 1:nLang) { for (morph.idx in 1:nMorph){
               mmorph[lang.idx,morph.idx,loc.idx]  <- location[loc.idx] + lang[lang.idx, loc.idx]  +  morph[morph.idx, loc.idx] + lang.morph[lang.idx,morph.idx,loc.idx]
            }}

           for (lang.idx in 1:nLang) { for (funct.idx in 1:nFunct){
               mfunct[lang.idx,funct.idx,loc.idx]  <- location[loc.idx] + lang[lang.idx, loc.idx]  + funct[funct.idx, loc.idx] + lang.funct[lang.idx,funct.idx,loc.idx]
            }}

           for (lang.idx in 1:nLang) { for (clausestatus.idx in 1:nClausestatus){
               mclausestatus[lang.idx,clausestatus.idx,loc.idx]  <- location[loc.idx] + lang[lang.idx, loc.idx]  + clausestatus[clausestatus.idx, loc.idx] + lang.clausestatus[lang.idx,clausestatus.idx,loc.idx]
            }}


           #Pitääkö erikseen mys 
           morphb0[loc.idx] <- mean(mmorph[1:nLang,1:nMorph,loc.idx])
           functb0[loc.idx] <- mean(mfunct[1:nLang,1:nFunct,loc.idx])
           clausestatusb0[loc.idx] <- mean(mclausestatus[1:nLang,1:nClausestatus,loc.idx])

           for(morph.idx in 1:nMorph){
               b.morph[morph.idx, loc.idx] <- mean(mmorph[1:nLang,morph.idx,loc.idx]) - morphb0[loc.idx]
               for(lang.idx in 1:nLang){
                   b.lang.morph[lang.idx, morph.idx, loc.idx] <- mmorph[lang.idx, morph.idx, loc.idx] - (morphb0[loc.idx] + lang[lang.idx, loc.idx] + b.morph[morph.idx, loc.idx])
               }
           }

           for(funct.idx in 1:nFunct){
               b.funct[funct.idx, loc.idx] <- mean(mfunct[1:nLang,funct.idx,loc.idx]) - functb0[loc.idx]
               for(lang.idx in 1:nLang){
                   b.lang.funct[lang.idx, funct.idx, loc.idx] <- mfunct[lang.idx, funct.idx, loc.idx] - (functb0[loc.idx] + lang[lang.idx, loc.idx] + b.funct[funct.idx, loc.idx])
               }
           }

           for(clausestatus.idx in 1:nClausestatus){
               b.clausestatus[clausestatus.idx, loc.idx] <- mean(mclausestatus[1:nLang,clausestatus.idx,loc.idx]) - clausestatusb0[loc.idx]
               for(lang.idx in 1:nLang){
                   b.lang.clausestatus[lang.idx, clausestatus.idx, loc.idx] <- mclausestatus[lang.idx, clausestatus.idx, loc.idx] - (clausestatusb0[loc.idx] + lang[lang.idx, loc.idx] + b.clausestatus[clausestatus.idx, loc.idx])
               }
           }

       }
}


