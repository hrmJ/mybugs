model{

       # LIKELIHOOD
       #==================================================================

       for (i in 1:nLang) {                                                                    # LANG
                for (j in 1:nMorph) {                                                      # MORPH
                    for (ref.idx in 1:nRef) {                                                      # MORPH
                         observations[i,j,ref.idx,1:Nlocations] ~ dmulti( probs[i,j,ref.idx,1:Nlocations] , totals[i,j,ref.idx]  )
                         for (k in 1:Nlocations) {                                         #y. LOCATIONS
                           probs[i,j,ref.idx,k]  <- phi[i,j,ref.idx,k] / sum(phi[i,j,ref.idx,1:Nlocations])
                           log(phi[i,j,ref.idx,k]) <- location[k] + lang[i,k]  +  morph[j,k]  + lang.morph[i,j,k] + b.ref[ref.idx,k] + b.lang.ref[i, ref.idx, k]
                         }#location
            } 

          }
       }


       # PRIORIT + interaktiot
       #==================================================================

           for(k in 1:Nlocations){
               alpha[k] <- 1
           }

           location[1:4] ~ ddirich(alpha[])

           #------------------------------------------------------------

           sigma.lang ~ dt(0,1,1) T(0,) #puoli-cauchy |-----------
           tau.lang  <- pow(sigma.lang,-2)

           for(k in 1:Nlocations){
                   lang.raw[k] ~ dnorm(0, tau.lang)
                   lang[1, k] <- lang.raw[k] - mean(lang.raw[])
                   lang[2, k] <- -lang[1,k]
           }

           #------------------------------------------------------------

           for(ref.idx in 1:nRef){
               ref[ref.idx, 1:Nlocations] ~ ddirich(alpha[])
               for(lang.idx in 1:nLang){
                   lang.ref[lang.idx, ref.idx, 1:Nlocations] ~ ddirich(alpha[])
               }
           }


       # morph
       #------------------------------------------------------------------

           sigma.morph ~ dt(0,1,1) T(0,) #puoli-cauchy |-----------
           tau.morph  <- pow(sigma.morph,-2)
           sigma.lang.morph ~ dt(0,1,1) T(0,) #puoli-cauchy |-----------
           tau.lang.morph  <- pow(sigma.lang.morph,-2)

           for(k in 1:Nlocations){
                   morph.raw[k] ~ dnorm(0, tau.morph)
                   morph[1,k] <- morph.raw[k] - mean(morph.raw[])
                   morph[2,k] <- -morph[1,k]

                   #interaktio
                   lang.morph.raw[k] ~  dnorm(0, tau.lang.morph)
                   lang.morph[1,1,k] <- lang.morph.raw[k] - mean(lang.morph.raw[])
                   lang.morph[1,2,k] <- -lang.morph[1,1,k]
                   lang.morph[2,1,k] <- -lang.morph[1,1,k]
                   lang.morph[2,2,k] <- lang.morph[1,1,k]
           }

           std[1] <- sd(location[])
           std[2] <- sd(lang[,])
           std[3] <- sd(morph[,])
           std[4] <- sd(lang.morph[,,])
           
           for (k in 1:Nlocations) {                                         #y. LOCATIONS
              gt0[k] <- step(lang.morph[1,1,k])
           }


       for(loc.idx in 1:Nlocations){
           #BASELINE = location[loc.idx]
           for (lang.idx in 1:nLang) { for(morph.idx in 1:nMorph){ for (ref.idx in 1:nRef){
               m[lang.idx,morph.idx,ref.idx,loc.idx]  <- location[loc.idx] + lang[lang.idx,loc.idx]  +  morph[morph.idx,loc.idx]  +   ref[ref.idx,loc.idx] + lang.ref[lang.idx,ref.idx,loc.idx] + lang.morph[lang.idx,morph.idx,loc.idx]
            }}}

           #Voiko näin tehdä?? >>
           for (lang.idx in 1:nLang) { for (ref.idx in 1:nRef){
               mref[lang.idx,ref.idx,loc.idx]  <- location[loc.idx] + lang[lang.idx, loc.idx]  +  ref[ref.idx, loc.idx] + lang.ref[lang.idx,ref.idx,loc.idx]
            }}

           b0[loc.idx] <- mean(m[1:nLang,1:nMorph,1:nRef,loc.idx])
           #Pitääkö erikseen mys 
           refb0[loc.idx] <- mean(mref[1:nLang,1:nRef,loc.idx])

           for(ref.idx in 1:nRef){
               b.ref[ref.idx, loc.idx] <- mean(mref[1:nLang,ref.idx,loc.idx]) - refb0[loc.idx]
               for(lang.idx in 1:nLang){
                   b.lang.ref[lang.idx, ref.idx, loc.idx] <- mref[lang.idx, ref.idx, loc.idx] - (refb0[loc.idx] + lang[lang.idx, loc.idx] + b.ref[ref.idx, loc.idx])
               }
           }

       }
}

